* [[http://cfd-china.com/topic/2191/openfoam%E5%91%A8%E6%9C%9F%E8%BE%B9%E7%95%8C%E7%94%9F%E6%88%90%E4%B8%8D%E6%88%90%E5%8A%9F-cyclic%E7%9A%84%E9%97%AE%E9%A2%98][why mesh not pass]]
** initial asking
   I am using OF-dev version (don't know exactly the date I downloaded
   it).

   The main classes are found in the flowing path:

   #+BEGIN_SRC 
   ~/OpenFOAM-dev/src/dynamicMesh/polyTopoChange/polyTopoChange/modifyObject/  
   #+END_SRC

   This for loop:

   #+BEGIN_SRC c++
   //Line 707
   //~/OpenFOAM-dev/applications/utilities/mesh/manipulation/createPatch/createPatch.C

   void changePatchID
 (
     const polyMesh& mesh,
     const label faceID,
     const label patchID,
     polyTopoChange& meshMod
 )
   #+END_SRC
  
   is the point that I feel something might wrong.
  
   I don't know exactly what ~polyModifyFace~ is a function or a
   class. I double checked the defination of ~polyModifyFace~:

   #+BEGIN_SRC c++
   //Line 82
   //~OpenFOAM-dev/src/dynamicMesh/polyTopoChange/polyTopoChange/modifyObject/polyModifyPoint.H
   meshMod.setAction
     (
         polyModifyFace
         (
             mesh.faces()[faceID],               // face
             faceID,                             // face ID
             mesh.faceOwner()[faceID],           // owner
             -1,                                 // neighbour
             false,                              // flip flux
             patchID,                            // patch ID
             false,                              // remove from zone
             zoneID,                             // zone ID
             zoneFlip                            // zone flip
         )
     );
   #+END_SRC

   I think ~polyModifyFace~ really looks like a function definitio in
   c++, but I migth wrong.
  
   Another thing that I feel strange is that the implymentation of the
   following classes are missing.

   #+BEGIN_SRC 
   3.5k 12-14 23:52 polyModifyCell.H
   7.5k 12-14 23:52 polyModifyFace.H
   4.2k 12-14 23:52 polyModifyPoint.H
   #+END_SRC

   Is that becasue those classes are too easy?

   I furthe study the class (~/OpenFOAM-dev/src/dynamicMesh/polyTopoChange/polyTopoChange/modifyObject/polyModifyFace.H):


   #+BEGIN_SRC c++
         //- Construct and return a clone
         virtual autoPtr<topoAction> clone() const
         {
             return autoPtr<topoAction>(new polyModifyFace(*this));
         }
   #+END_SRC

   Is this ~clone()~ function mess up all the things? If so, what's the
   limited of it? How big (size of the mesh) the OF can handle?

   I agree with you. This mesh is converted from *.msh file without any
   issue. ~createPatch~ seems have a much large memery requirment. I am
   not sure exactly the order of it.

   What I want to do, is to run some small test to investigate the
   memery usage of ~convertMesh~ and ~creatPatch~.

   Finally, why make it (~matchToTolerance~) smaller? Do you have any
   reference to this point? I might (can remember exactly) just use
   some default number here.
  
** 2nd round
   The reason why I checked ~polyModifyFace~ was that I wanted to study
   the piece of code in:
  #+BEGIN_SRC c++
  //Line 82
  ///OpenFOAM-dev/applications/utilities/mesh/manipulation/createPatch/createPatch.C
  meshMod.setAction
    (
        polyModifyFace
        (
            mesh.faces()[faceID],               // face
            faceID,                             // face ID
            mesh.faceOwner()[faceID],           // owner
            -1,                                 // neighbour
            false,                              // flip flux
            patchID,                            // patch ID
            false,                              // remove from zone
            zoneID,                             // zone ID
            zoneFlip                            // zone flip
        )
    );
  #+END_SRC

  I don't know the reason why it crash, that's why I am asking.

  #+BEGIN_SRC c++
  //188
  return autoPtr<topoAction>(new polyModifyFace(*this));
  #+END_SRC

  Do you know how this function could trigger the following exception:

  #+BEGIN_SRC c++
  terminate called after throwing an instance of 'std::bad_array_new_length'
  what():  std::bad_array_new_length
  #+END_SRC

  I don't know.
  
  @wwzhao thanks for helping. This test case was built ~Jul 06 2018~,
  so I am not sure the exactly envirmental varibles that I was playing with.

  I've double checked the ~LABEL_SIZE~

  #+BEGIN_SRC sh
  echo $WM_LABEL_SIZE
  32
  #+END_SRC

  It looks like a right direction to further study this stuff. But, it
  needs more time, since I need to rebuid OF. Which Version would you
  like to suggest me to run? dev or v4.1?

  Also, if the default $WM_LABEL_SIZE is indeed 32, what is its
  theoretical upper limmited, i.e. running pisoFoam (motobike tutorial?).

  Can I change to any number (2^{5,6,7,8})?

** reply to wwzhao: study $WM_LABEL_SIZE
   What is the meaning of:

   #+BEGIN_QUOTE
   label representing for the sizes of point, face, and cell.
   #+END_QUOTE

   I read this book: The OpenFOAM technology primer. On page, 41, in
   the paragrah: points, the last sentence writes:

   #+BEGIN_QUOTE
   The position is stored as ~label~;

   This (faces) is a nested list, containing one element per face.
   #+END_QUOTE

   From my understanding, one ~label~ means a single point's xyz
   location stored in the ~constant/polyMesh/points~ file.

   So, to represent a single face, one need a ~labelList~ and a
   ~labelListList~ to give sufficient info to the computer.
   
   For example, you have a point whose coordinates is (-0.0206 0
   -0.0005) and we denote it as a label, i.e., 1.

   I may constructure 4 points just what I've done. Then, I got a list
   of list: 1,2,3,and 4.

   If I have that list of list, I would say that I've already define a
   face. This is ture, as you can see the example given at page 42:

   #+BEGIN_QUOTE
   // Face 0 with it's four point labels as labelsit
   4(1 20 172 153)
   #+END_QUOTE
** change from 32 to 64 not always success
   I recently read [[https://github.com/sbeamer/gapbs/issues/9][an issue]], the reporter has a similar error
   (although he used different software):

   #+BEGIN_SRC c++
   ./converter -f benchmark/graphs/raw/twitter.el -b benchmark/graphs/twitter.sg
Read Time:           57.28654
terminate called after throwing an instance of 'std::bad_array_new_length'
  what():  std::bad_array_new_length
  make: *** [benchmark/graphs/twitter.sg] Aborted
   #+END_SRC
   
   He changed the software from:
   #+BEGIN_SRC c++
   typedef int64_t NodeID;
typedef int64_t WeightT;
If I change it back to 32 bit, the error goes away.
typedef int32_t NodeID;
typedef int32_t WeightT;
   #+END_SRC

   At the end of that conversation, the reporter mentioned the reason
   why this error exists is because of the dowonloading issue by
   comparing MD5 hashes.
   
   So, I think I need further investigate this issue before I really
   made something on cluster.

** what is ~clone()~
   As I further read the source code of
   ~/OpenFOAM-dev/src/dynamicMesh/polyTopoChange/polyTopoChange/modifyObject/polyModifyFace.H~

   I found myself not understand:

   #+BEGIN_SRC c++
   // 187
        //- Construct and return a clone
        virtual autoPtr<topoAction> clone() const
        {
            return autoPtr<topoAction>(new polyModifyFace(*this));
        }
   #+END_SRC

   What is meaning of this constructor? Which class use this function?

   I later found the the class using ~clone()~:
   ~/OpenFOAM-dev/src/dynamicMesh/polyTopoChange/polyTopoChange/topoAction/topoAction.H~

   what does this mean?
   ~const = 0~
   #+BEGIN_SRC c++
   virtual autoPtr<topoAction> clone() const = 0;
   #+END_SRC
   
   This is a pure virtual function. but what's wrong with const?

   I found this piece of code explain the ~const~ stuff very well.

   #+BEGIN_SRC c++
#include "pch.h"
#include <iostream>
#include <string>

class MyClass
{
private:
	int var;

public:
	void MyFunc() { var = 3; }

	void MyConstFunc() const
	{
	}

};


int main()
{
	MyClass c;

	c.MyFunc();        // ok
	c.MyConstFunc();   // ok

	const MyClass m;

	m.MyConstFunc();   // ok
	m.MyFunc();        // not ok, it's not const

} 
#+END_SRC
** Why there is nothing in Destructor
   #+BEGIN_SRC c++
   //194
   // Default Destructor
   #+END_SRC
** something interesting
   cyclist: 1c1707e8a20719056bfc9a232527c5bd
** [[https://www.learncpp.com/cpp-tutorial/24-integers/#comment-377315][int_32 and int_64]]
   Does my OF a 32 version? How to check OF is a 32 or 64 version application?
   #+BEGIN_SRC sh
   $ file pisoFoam
   pisoFoam: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /cvmfs/soft.computecanada.ca/nix/var/nix/profiles/16.09/lib/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=66306ba1b0d4e34b5b7267398e679fb58d23c619, not stripped
   #+END_SRC

   what is ~size_t~?

   why 4 bytes is 32-bit?

   a byte has a total number of 256 states ( 0 through 255 ), which is
   ( 2 in power of 8 = 256 )

   So, 4 bytes, you gana have 4 * 8 = 32 bit states, which is ( 2 in
   power of 32 = 4294967296)

   Why I cannot build 64-bit project on my 64-bit machine (I am using )?

   Yes you can, just choice x64 debugger.
   #+BEGIN_SRC c++
#include "pch.h"
#include <iostream>
#include <stdio.h>
#include <string>
#include <chrono>


using namespace std;

class Timer
{
private:
	// Type aliases to make accessing nested type easier                                                                                                                                          
	using clock_t = std::chrono::high_resolution_clock;
	using second_t = std::chrono::duration<double, std::ratio<1> >;

	std::chrono::time_point<clock_t> m_beg;

public:
	Timer() : m_beg(clock_t::now())
	{
	}

	void reset()
	{
		m_beg = clock_t::now();
	}

	double elapsed() const
	{
		return std::chrono::duration_cast<second_t>(clock_t::now() - m_beg).count();
	}
};

class dummy
{
private:
	int m_array[1];

public:
	dummy() // zero the member array                                                                                                                                                  
	{
		// If we want the array to have values, we'll have to use assignment here                                                                                                                    
		m_array[0] = 4294967295;
	}
};


int main()
{
	Timer x32_timer;
	dummy x32;
	std::cout << "Time elapsed: " << x32_timer.elapsed() << "\n";
	// x32 Time elapsed: 1.956e-06
	// x64 Time elapsed: 3.424e-06
	// almost 1.8 time slower.
    std::cout << "Hello World!\n";
}
   #+END_SRC
